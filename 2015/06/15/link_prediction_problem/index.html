<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Link Prediction Problem | Notes</title>
  <meta name="author" content="Shichao Yuan">
  
  <meta name="description" content="1最近在看一些好友推荐的东西，所以就多google了一下。
看到一篇论文《The Link Prediction Problem for Social Networks》，感觉写的很不错。
（对这种形式化的描述没抵抗力 :-D）
所以就是做个笔记吧。
2首先social networks可以理解为图">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Link Prediction Problem"/>
  <meta property="og:site_name" content="Notes"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Notes</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">		
			<h1> Link Prediction Problem</h1>
		</div>		
	



<div class="row post">
	<!-- cols -->
	
	<div class="col-md-9">
	

			

	<!-- content -->
	<div class="mypage">		
	    <h2 id="1">1</h2><p>最近在看一些好友推荐的东西，所以就多google了一下。</p>
<p>看到一篇论文<a href="http://www.cs.cornell.edu/home/kleinber/link-pred.pdf" target="_blank" rel="external">《The Link Prediction Problem for Social Networks》</a>，感觉写的很不错。</p>
<p>（对这种形式化的描述没抵抗力 :-D）</p>
<p>所以就是做个笔记吧。</p>
<h2 id="2">2</h2><p>首先<em>social networks</em>可以理解为图，其中<em>nodes</em>表示人或者其他实体，<em>edges</em>标示交互、协作或者关系。</p>
<p>那么好友推荐的问题就可以理解为基于原有的好友关系图结构，预测可能出现的新的关系。</p>
<p>更一般的，可以理解为<em>link prediction problem</em>，基于原有的图结构，预测图的演化。</p>
<blockquote>
<p>the <em>link prediction problem</em>：</p>
<p>Given a snapshot of a social network at time <em>t</em>, we seek to accurately predict the edges that will be added to the network during the interval from time $t$ to a given future time $t’$.</p>
</blockquote>
<p>当然现实中的交互和关系有很多原因，单单从图结构中是分析不出来的。</p>
<p>但是</p>
<blockquote>
<p>We find that a number of proximity measures lead to predictions that outperform chance by factors of 40 to 50, indicating that the network topology does indeed contain latent information from which to infer future interactions.</p>
</blockquote>
<p>（是这样么？ 暂且相信一下吧，不然就没法继续读下去了 :-D）</p>
<h2 id="3">3</h2><p>形式化这个问题。</p>
<p>social network: $G = \langle V, E \rangle$</p>
<p>each edge: $e = \langle u, v \rangle \in E$</p>
<p>表示$u,v$在特定时间$t(e)$发生交互，其中多次交互记录为并行的边。</p>
<p>$G[t, t’]$表示某时间段内$(t &lt; t’)$的子图。</p>
<p>另外这篇文章为了评估不同的算法还是定义训练和测试的方法：</p>
<blockquote>
<p>We choose four times $t_0 &lt; t’_0 &lt; t_1 &lt; t’_1$, and give an algorithm access to the network $G[t_0,t’_0]$; it must then output a list of edges, not present in $G[t_0,t’_0]$, that are predicted to appear in the network $G[t_1,t’_1]$. We refer to $[t_0,t’_0]$ as the <em>training interval</em> and $[t_1,t’_1]$ as the <em>test interval</em>.</p>
<p>Thus, in evaluating link prediction methods, we will generally use two parameters $\mit{κ<em>{training}}$ and $\mit{κ</em>{test}}$ (each set to 3 below), and define the set <strong>Core</strong> to be all nodes incident to at least $\mit{κ<em>{training}}$ edges in $G[t_0, t’_0]$ and at least $\mit{κ</em>{test}}$ edges in $G[t_1,t’_1]$. We will then evaluate how accurately the new edges between elements of <strong>Core</strong> can be predicted.</p>
<p>We define the training interval to be the three years $[1994, 1996]$, and the test interval to be $[1997, 1999]$. We denote the subgraph $G[1994, 1996]$ on the training interval by $G<em>{collab} := \langle A, E</em>{old} \rangle $, and use $E_{new}$ to denote the set of edges $\langle u, v \rangle$ such that $u, v \in A$, and $u, v$ co-author a paper during the test interval but not the training interval — these are the new interactions we are seeking to predict.</p>
</blockquote>
<p>评估的方法如下：</p>
<blockquote>
<p>Each link predictor $p$ that we consider outputs a ranked list $L<em>p$ of pairs in $A×A−E</em>{old}$; these are predicted new collaborations, in decreasing order of confidence. For our evaluation, we focus on the set <strong>Core</strong>, so we define $E^∗<em>{new} := E</em>{new} \cap (Core \times Core)$ and $n := |E^∗<em>{new}|$. Our performance measure for predictor $p$ is then determined as follows: from the ranked list $L_p$, we take the first $n$ pairs in $Core \times Core$, and determine the size of the intersection of this set of pairs with the set $E^∗</em>{new}$.</p>
</blockquote>
<h2 id="4">4</h2><p>定义方法的输入输出。</p>
<p>输入：$G_{collab}$</p>
<p>输出：$score(x, y)$降序的列表</p>
<p>基本上可以理解为通过原有的图结构计算节点$x,y$之间的proximity。</p>
<p>最基本的方法就是计算$G_{collab}$中$x, y$的最短路径，为了保持结果降序排列，对路径长度取负值，其中等于1的路径属于训练图。</p>
<h2 id="5">5</h2><p>Methods based on node neighborhoods</p>
<p>$\Gamma(x)$表示图$G_{collab}$中节点$x$的邻居的集合。</p>
<p>直觉上来说，相同的邻居更多的连个节点更容易产生关系，这类方法就是基于这个假设。</p>
<h3 id="Common_neighbors">Common neighbors</h3><p>$score(x, y) := \mid\Gamma(x)\cap\Gamma(y)\mid $</p>
<h3 id="Jaccard’s_coefficient_and_Adamic/Adar">Jaccard’s coefficient and Adamic/Adar</h3><p>Jaccard’s coefficient通常用于信息检索中的相似度测量，</p>
<p>$score(x, y) := \mid\Gamma(x)\cap\Gamma(y)\mid/\mid\Gamma(x)\cup\Gamma(y)\mid$</p>
<p>Adamic/Adar加大了稀有特征的权重，</p>
<p>$score(x,y) := \sum\nolimits_{z\in\Gamma(x)\cap\Gamma(y)}\frac{1}{\log\mid\Gamma(z)\mid}$</p>
<h3 id="Preferential_attachment">Preferential attachment</h3><p>该方法的基本的假设是节点涉及新边的概率与其邻居的数量成正比，</p>
<p>$score(x,y) := \mid\Gamma(x)\mid\cdot\mid\Gamma(y)\mid$</p>
<h2 id="6">6</h2><p>Methods based on the ensemble of all paths</p>
<p>这类方法基于最短路径的思路，不过是考虑了两点之间所有路径。</p>
<h3 id="Katz">Katz</h3><p>$score(x,y) := \sum\limits<em>{l=1}^{\infty}\beta^l\cdot\mid paths</em>{x,y}^{\langle l \rangle} \mid$</p>
<p>$paths_{x,y}^{\langle l \rangle} := {paths\ of\ length\ exactly\ l\ from\ x\ to\ y}$</p>
<p>当$\beta$值比较小的时候，结果基本与common neighbors方法类似。</p>
<p>此外该方法还分为加权、不加权两种：</p>
<p>weighted: $paths_{x,y}^{\langle 1 \rangle} := number\ of\ collaborations\ between\ x,y.$</p>
<p>unweighted: $paths_{x,y}^{\langle 1 \rangle} := 1\ iff\ x\ and\ y\ collaborate.$</p>
<h3 id="Hitting_times,_PageRank,_and_variants">Hitting times, PageRank, and variants</h3><p>该方法的思想是在$G_{collab}$上进行<em>random walk</em></p>
<p><em>hitting time</em> $H_{x,y}$标示从$x$到$y$的期望的步数</p>
<p><em>commute time</em> $C<em>{x,y} := H</em>{x,y} + H_{y,x}$</p>
<p>但是当$y$的<em>stationary probability</em> $\pi<em>y$比较大的时候，对于任意$x$，$H</em>{x,y}$的值都很小，所以做一点儿归一化。</p>
<p>$score(x,y) := -H_{x,y}\cdot\pi_y$</p>
<p>$score(x,y) := -(H<em>{x,y}\cdot\pi_y + H</em>{y,x}\cdot\pi_x)$</p>
<p>但是这种测量方法还有一个问题，其测量值对图部分的结构更敏感，所以在<em>random walk</em>中加入固定的概率$\alpha$退回。</p>
<blockquote>
<p>rooted PageRank</p>
<p>stationary distribution weight of $y$ under the following random walk:</p>
<p>with probability $\alpha$, jump to $x$.</p>
<p>with probability $1-\alpha$, go to random neighbor of current node.</p>
</blockquote>
<h3 id="SimRank">SimRank</h3><p>$score(x,y) := \begin{equation}\left {\begin{array}\\gamma\cdot\frac{\sum\nolimits<em>{a\in\Gamma(x)}\sum\nolimits</em>{b\in\Gamma(y)}score(a,b)}{\mid\Gamma(x)\mid\cdot\mid\Gamma(y)\mid} &amp; otherwise \1 &amp; if\ x = y\end{array}\right.\end{equation}$</p>
<p>$\gamma\in[0,1]$</p>
<blockquote>
<p>SimRank can also be interpreted in terms of a random walk on the collaboration graph: it is the expected value of $\gamma^l$, where $l$ is a random variable giving the time at which random walks started from $x$ and $y$ first meet.</p>
</blockquote>
<h2 id="7">7</h2><p>Higher-level approaches</p>
<p>三个meta-approaches，可以结合任一上述方法。</p>
<h3 id="Low-rank_approximation">Low-rank approximation</h3><p>上述算法都可以转换为矩阵运算，那么就可以用SVD降秩，这也可以看做为一种noise-reduction的方法。</p>
<h3 id="Unseen_bigrams">Unseen bigrams</h3><blockquote>
<p>Link prediction is akin to the problem of estimating frequencies for unseen bigrams in language modeling—pairs of words that co-occur in a test corpus, but not in the corresponding training corpus.</p>
<p>we can augment our estimates for $score(x, y)$ using values of $score(z, y)$ for nodes $z$ that are “similar” to $x$.</p>
</blockquote>
<p>$score_{unweighted}^*(x,y) := \mid{z:z\in\Gamma(y)\cap S_x^{\langle\delta\rangle}}\mid$</p>
<p>$score<em>{weighted}^*(x,y) := \sum\nolimits</em>{z\in\Gamma(y)\cap S_x^{\langle\delta\rangle}}score(x,z)$</p>
<p>$S_x^{\langle\delta\rangle}$表示基于$score(x,\cdot)$与$x$最相关的$\delta$个节点。</p>
<h3 id="Clustering">Clustering</h3><p>通过聚类删除一些tenuous的边，然后在cleaned-up的子图上进行计算。</p>
<h2 id="8">8</h2><p>一些结论</p>
<blockquote>
<p>the small world problem is really a problem. The shortest path between two scientists in wholly unrelated disciplines is often very short (and very tenuous).</p>
<p>Overall, the basic graph distance predictor is not competitive with most of the other approaches studied; our most successful link predictors can be viewed as using measures of proximity that are robust to the few edges that result from rare collaborations between fields.</p>
</blockquote>
<p>AA还是不错的。</p>
<blockquote>
<p>The small world problem suggests that there are many pairs with graph distance two that will not collaborate, but we also observe the dual problem: many pairs that collaborate are at distance larger than two.</p>
</blockquote>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2015/06/30/weak-reference/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2015/05/26/geonear/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>

  
</section>

	
	</div> <!-- col-md-9/col-md-12 -->
	
	
		<div class="col-md-3"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2015-06-15 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/algorithm/">algorithm<span>2</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	

</div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2015 Shichao Yuan
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>


<!-- mathjax config similar to math.stackexchange -->
 
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
 
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>
 
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
 
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
   </html>
